<h2>Manage Unavailability</h2>

<button type="button" class="btn btn-primary mb-3" id="openRecurringModalBtn">
  Add Recurring Unavailability
</button>

<div id="calendar-container"
     data-psychologist-profile-id="<%= @psychologist_profile.id %>"
     data-psychologist-timezone="<%= @psychologist_profile.timezone %>">
  <div class="timezone-info mb-2">
    <small class="text-muted">Calendar displayed in: <%= @psychologist_profile.timezone %></small>
  </div>
  <div id="calendar"></div>
</div>

<div class="custom-modal-overlay" id="recurringUnavailabilityModal">
  <div class="custom-modal-content">
    <div class="custom-modal-header">
      <h5 class="custom-modal-title" id="recurringUnavailabilityModalLabel">Add Recurring Unavailability</h5>
      <button type="button" class="custom-modal-close" id="closeRecurringModalBtn" aria-label="Close">&times;</button>
    </div>
    <div class="custom-modal-body">
      <form id="recurringUnavailabilityForm">
        <div class="mb-3">
          <label for="recurringReason" class="form-label">Reason</label>
          <input type="text" class="form-control" id="recurringReason" required>
        </div>
        <div class="mb-3">
          <label for="recurringStartTime" class="form-label">Start Time</label>
          <input type="time" class="form-control" id="recurringStartTime" required>
          <small class="form-text text-muted">Time in <%= @psychologist_profile.timezone %></small>
        </div>
        <div class="mb-3">
          <label for="recurringEndTime" class="form-label">End Time</label>
          <input type="time" class="form-control" id="recurringEndTime" required>
          <small class="form-text text-muted">Time in <%= @psychologist_profile.timezone %></small>
        </div>
        <div class="mb-3">
          <label class="form-label">Repeat On</label><br>
          <div class="form-check form-check-inline">
            <input class="form-check-input" type="checkbox" name="recurring_day_of_week" id="dayMon" value="1">
            <label class="form-check-label" for="dayMon">Mon</label>
          </div>
          <div class="form-check form-check-inline">
            <input class="form-check-input" type="checkbox" name="recurring_day_of_week" id="dayTue" value="2">
            <label class="form-check-label" for="dayTue">Tue</label>
          </div>
          <div class="form-check form-check-inline">
            <input class="form-check-input" type="checkbox" name="recurring_day_of_week" id="dayWed" value="3">
            <label class="form-check-label" for="dayWed">Wed</label>
          </div>
          <div class="form-check form-check-inline">
            <input class="form-check-input" type="checkbox" name="recurring_day_of_week" id="dayThu" value="4">
            <label class="form-check-label" for="dayThu">Thu</label>
          </div>
          <div class="form-check form-check-inline">
            <input class="form-check-input" type="checkbox" name="recurring_day_of_week" id="dayFri" value="5">
            <label class="form-check-label" for="dayFri">Fri</label>
          </div>
          <div class="form-check form-check-inline">
            <input class="form-check-input" type="checkbox" name="recurring_day_of_week" id="daySat" value="6">
            <label class="form-check-label" for="daySat">Sat</label>
          </div>
          <div class="form-check form-check-inline">
            <input class="form-check-input" type="checkbox" name="recurring_day_of_week" id="daySun" value="0">
            <label class="form-check-label" for="daySun">Sun</label>
          </div>
        </div>
        <div class="mb-3">
          <label for="recurringUntilDate" class="form-label">Repeat Until (Optional)</label>
          <input type="date" class="form-control" id="recurringUntilDate">
        </div>
        <input type="hidden" id="recurringTimezoneInput" name="psychologist_unavailability[timezone]">
        <button type="submit" class="btn btn-success">Save Recurring Unavailability</button>
      </form>
    </div>
  </div>
</div>

<script>
document.addEventListener('turbo:load', function () {
    const calendarEl = document.getElementById('calendar');
    const container = document.getElementById('calendar-container');
    const psychologistProfileId = container ? container.dataset.psychologistProfileId : null;
    const psychologistTimeZone = container ? container.dataset.psychologistTimezone : null;

    if (!calendarEl || !container || !psychologistProfileId || !psychologistTimeZone) {
        console.error("Critical elements, psychologist profile ID, or timezone missing. Calendar cannot initialize.");
        if (!psychologistTimeZone) {
            alert("Your profile timezone is not set. Please update your profile to ensure calendar displays correctly.");
        }
        return;
    }

    const calendar = new FullCalendar.Calendar(calendarEl, {
        initialView: 'timeGridWeek',
        slotMinTime: "06:00:00",
        slotMaxTime: "22:00:00",
        allDaySlot: false,
        editable: true,
        selectable: true,
        firstDay: 1, // Monday
        timeZone: psychologistTimeZone, // Display everything in psychologist's timezone
        displayEventTime: true,

        eventTimeFormat: {
            hour: 'numeric',
            minute: '2-digit',
            meridiem: 'short'
        },
        slotLabelFormat: {
            hour: 'numeric',
            minute: '2-digit',
            omitZeroMinute: false,
            meridiem: 'short'
        },
        headerToolbar: {
            left: 'prev,next today',
            center: 'title',
            right: 'dayGridMonth,timeGridWeek,timeGridDay'
        },

        // Event creation via selection (one-off)
        select: function(info) {
            const reason = prompt("Reason for one-off unavailability?");
            if (reason === null || reason.trim() === "") {
                alert("Unavailability reason cannot be blank. One-off event not created.");
                return;
            }

            // Create date objects in the psychologist's timezone
            const startInPsychTz = new Date(info.start.getTime());
            const endInPsychTz = new Date(info.end.getTime());

            fetch('/psychologist_unavailabilities.json', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': document.querySelector("[name='csrf-token']").content
                },
                body: JSON.stringify({
                    psychologist_unavailability: {
                        psychologist_profile_id: psychologistProfileId,
                        // Send the datetime in ISO format - FullCalendar handles timezone conversion
                        start_time: startInPsychTz.toISOString(),
                        end_time: endInPsychTz.toISOString(),
                        reason: reason,
                        recurring: false,
                        timezone: psychologistTimeZone
                    }
                })
            })
            .then(response => {
                if (response.ok) {
                    calendar.refetchEvents();
                    alert("One-off unavailability saved successfully!");
                } else {
                    response.json().then(errors => {
                        console.error("Server-side validation errors for one-off:", errors);
                        alert("Error saving one-off unavailability: " + JSON.stringify(errors));
                    }).catch(() => {
                        alert("Error saving one-off unavailability. Could not parse error response from server.");
                    });
                }
            })
            .catch(error => {
                console.error("Network or Fetch error for one-off:", error);
                alert("A network error occurred while saving one-off unavailability.");
            });
        },

        eventClick: function(info) {
            const isUnavailability = info.event.source && info.event.source.url === `/psychologist_unavailabilities.json?psychologist_profile_id=${psychologistProfileId}`;

            if (isUnavailability && info.event.id) {
                const isRecurringInstance = info.event.extendedProps && info.event.extendedProps.recurring;

                // Format times in the psychologist's timezone for display
                const startTime = info.event.start.toLocaleString('en-US', {
                    timeZone: psychologistTimeZone,
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: 'numeric',
                    minute: '2-digit',
                    timeZoneName: 'short'
                });
                const endTime = info.event.end.toLocaleString('en-US', {
                    timeZone: psychologistTimeZone,
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: 'numeric',
                    minute: '2-digit',
                    timeZoneName: 'short'
                });

                let confirmationMessage = '';
                if (isRecurringInstance) {
                    confirmationMessage = `This is a recurring unavailability instance. Do you want to delete the ENTIRE recurring rule (all future occurrences) for "${info.event.title}"?`;
                } else {
                    confirmationMessage = `Are you sure you want to delete this one-off unavailability from ${startTime} to ${endTime}?`;
                }

                if (confirm(confirmationMessage)) {
                    fetch(`/psychologist_unavailabilities/${info.event.id}.json`, {
                        method: 'DELETE',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRF-Token': document.querySelector("[name='csrf-token']").content
                        }
                    })
                    .then(response => {
                        if (response.ok) {
                            calendar.refetchEvents();
                            alert("Unavailability deleted successfully.");
                        } else {
                            response.json().then(errors => {
                                console.error("Server-side deletion errors:", errors);
                                alert("Error deleting unavailability: " + JSON.stringify(errors));
                            }).catch(() => {
                                alert(`Error deleting unavailability. Status: ${response.status} ${response.statusText}. Could not parse error response.`);
                            });
                        }
                    })
                    .catch(error => {
                        console.error("Network or Fetch error during deletion:", error);
                        alert("A network error occurred while deleting unavailability.");
                    });
                }
            } else {
                alert("This event is not an unavailability record or cannot be deleted from here.");
            }
        },

        eventSources: [
            {
                url: `/psychologist_unavailabilities.json?psychologist_profile_id=${psychologistProfileId}`,
                method: 'GET',
                color: '#d9534f',
                textColor: 'white',
                failure: function() {
                    alert('There was an error fetching your unavailabilities.');
                }
            },
            {
                url: `/psychologist_profiles/${psychologistProfileId}/psychologist_availabilities/calendar_blocks`,
                method: 'GET',
                display: 'background',
                color: '#d4edda',
                failure: function() {
                    alert('There was an error fetching your general availability blocks.');
                }
            }
        ]
    });

    calendar.render();
    window.myCalendar = calendar;

    // Custom Modal Handling
    const recurringUnavailabilityModal = document.getElementById('recurringUnavailabilityModal');
    const openRecurringModalBtn = document.getElementById('openRecurringModalBtn');
    const closeRecurringModalBtn = document.getElementById('closeRecurringModalBtn');
    const recurringUnavailabilityForm = document.getElementById('recurringUnavailabilityForm');
    const recurringTimezoneInput = document.getElementById('recurringTimezoneInput');

    openRecurringModalBtn.addEventListener('click', function() {
        recurringUnavailabilityModal.style.display = 'flex';
    });

    function hideRecurringModal() {
        recurringUnavailabilityModal.style.display = 'none';
        recurringUnavailabilityForm.reset();
    }

    closeRecurringModalBtn.addEventListener('click', hideRecurringModal);

    recurringUnavailabilityModal.addEventListener('click', function(event) {
        if (event.target === recurringUnavailabilityModal) {
            hideRecurringModal();
        }
    });

    // Set the timezone input to the psychologist's timezone
    if (recurringTimezoneInput) {
        recurringTimezoneInput.value = psychologistTimeZone;
    } else {
        console.warn("Hidden recurringTimezoneInput not found. Timezone might not be correctly submitted for recurring unavailabilities.");
    }

    recurringUnavailabilityForm.addEventListener('submit', function(event) {
        event.preventDefault();

        const reason = document.getElementById('recurringReason').value.trim();
        const startTime = document.getElementById('recurringStartTime').value;
        const endTime = document.getElementById('recurringEndTime').value;
        const recurringUntil = document.getElementById('recurringUntilDate').value;
        const timezone = recurringTimezoneInput.value;

        const selectedDays = Array.from(document.querySelectorAll('input[name="recurring_day_of_week"]:checked'))
                                .map(cb => parseInt(cb.value));

        if (!reason) {
            alert("Please provide a reason for the recurring unavailability.");
            return;
        }
        if (!startTime || !endTime) {
            alert("Please provide both start and end times for the recurring unavailability.");
            return;
        }
        if (selectedDays.length === 0) {
            alert("Please select at least one day of the week for recurrence.");
            return;
        }

        const DUMMY_DATE = '2000-01-01';

        const fetchPromises = selectedDays.map(dayOfWeek => {
            return fetch('/psychologist_unavailabilities.json', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': document.querySelector("[name='csrf-token']").content
                },
                body: JSON.stringify({
                    psychologist_unavailability: {
                        psychologist_profile_id: psychologistProfileId,
                        start_time: `${DUMMY_DATE}T${startTime}:00`,
                        end_time: `${DUMMY_DATE}T${endTime}:00`,
                        reason: reason,
                        recurring: true,
                        day_of_week: dayOfWeek,
                        recurring_until: recurringUntil || null,
                        timezone: timezone
                    }
                })
            });
        });

        Promise.all(fetchPromises)
            .then(responses => {
                let allSuccessful = true;
                const allErrors = [];

                return Promise.all(responses.map((response, index) => {
                    if (!response.ok) {
                        allSuccessful = false;
                        const dayName = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][selectedDays[index]];
                        return response.json().then(data => {
                            if (data && typeof data === 'object') {
                                const errorMessages = Object.entries(data).map(([key, value]) => `${key}: ${value.join(', ')}`).join('; ');
                                allErrors.push(`Error for ${dayName}: ${errorMessages}`);
                            } else {
                                allErrors.push(`Error for ${dayName}: ${response.statusText}`);
                            }
                        }).catch(() => {
                            allErrors.push(`Error for ${dayName}: ${response.status} ${response.statusText} (Could not parse error response).`);
                        });
                    }
                    return Promise.resolve();
                })).then(() => {
                    if (allSuccessful) {
                        alert("Recurring unavailability(ies) saved successfully!");
                        hideRecurringModal();
                        calendar.refetchEvents();
                    } else {
                        const finalErrorMessage = "Some recurring unavailabilities failed to save:\n" + allErrors.join("\n");
                        alert(finalErrorMessage);
                        calendar.refetchEvents();
                    }
                });
            })
            .catch(error => {
                console.error("Overall Network or Fetch error during recurring unavailability save:", error);
                alert("A network error occurred while saving recurring unavailabilities.");
            });
    });
});
</script>

<style>
    .custom-modal-overlay {
        display: none; /* Hidden by default */
        position: fixed; /* Stay in place */
        z-index: 1000; /* Sit on top */
        left: 0;
        top: 0;
        width: 100%; /* Full width */
        height: 100%; /* Full height */
        overflow: auto; /* Enable scroll if needed */
        background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
        align-items: center; /* Center content vertically */
        justify-content: center; /* Center content horizontally */
    }

    .custom-modal-content {
        background-color: #fefefe;
        margin: auto; /* For browsers that don't support align-items/justify-content */
        padding: 20px;
        border: 1px solid #888;
        width: 80%; /* Could be responsive */
        max-width: 500px; /* Max width for larger screens */
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        position: relative; /* Needed for close button positioning */
    }

    .custom-modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid #eee;
        padding-bottom: 10px;
        margin-bottom: 15px;
    }

    .custom-modal-title {
        margin: 0;
        font-size: 1.25rem;
        font-weight: 500;
    }

    .custom-modal-close {
        color: #aaa;
        font-size: 28px;
        font-weight: bold;
        cursor: pointer;
        background: none;
        border: none;
        padding: 0;
    }

    .custom-modal-close:hover,
    .custom-modal-close:focus {
        color: #000;
        text-decoration: none;
        cursor: pointer;
    }

    /* Basic styling for form elements to make them look decent without Bootstrap */
    .form-label {
        display: block;
        margin-bottom: 0.5rem;
        font-weight: bold;
    }

    .form-control {
        display: block;
        width: 100%;
        padding: 0.375rem 0.75rem;
        font-size: 1rem;
        line-height: 1.5;
        color: #495057;
        background-color: #fff;
        background-clip: padding-box;
        border: 1px solid #ced4da;
        border-radius: 0.25rem;
        transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
    }

    .form-check-inline {
        display: inline-block;
        margin-right: 1rem;
    }

    .form-check-input {
        margin-right: 0.375rem;
    }

    .btn {
        display: inline-block;
        font-weight: 400;
        color: #212529;
        text-align: center;
        vertical-align: middle;
        cursor: pointer;
        user-select: none;
        background-color: transparent;
        border: 1px solid transparent;
        padding: 0.375rem 0.75rem;
        font-size: 1rem;
        border-radius: 0.25rem;
        transition: color 0.15s ease-in-out, background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
    }

    .btn-primary {
        color: #fff;
        background-color: #0d6efd;
        border-color: #0d6efd;
    }

    .btn-primary:hover {
        color: #fff;
        background-color: #0b5ed7;
        border-color: #0a58ca;
    }

    .btn-success {
        color: #fff;
        background-color: #198754;
        border-color: #198754;
    }

    .btn-success:hover {
        color: #fff;
        background-color: #157347;
        border-color: #146c43;
    }
</style>


<label class="form-label" for="tzSelect">Calendar timeâ€‘zone</label>
<select id="tzSelect" class="form-select mb-3">
  <% ActiveSupport::TimeZone.all.each do |tz| %>
    <option value="<%= tz.name %>"><%= tz.tzinfo.name %></option>
  <% end %>
</select>