<div class="container is-fluid p-4">
  <div class="box p-6">
    <h1 class="title is-3 has-text-centered has-text-grey-dark mb-5">
      <%= @psychologist_profile.first_name %>'s Availability
    </h1>
    <p class="subtitle is-5 has-text-centered has-text-grey-dark mb-5">
      Times shown in your local timezone: <span id="browser-timezone">Loading...</span>
    </p>

    <% if notice %>
      <div class="notification is-success is-light mb-4">
        <button class="delete" onclick="this.parentElement.remove()"></button>
        <%= notice %>
      </div>
    <% end %>
    <% if alert %>
      <div class="notification is-danger is-light mb-4">
        <button class="delete" onclick="this.parentElement.remove()"></button>
        <%= alert %>
      </div>
    <% end %>

    <%= form_with url: psychologist_profile_psychologist_availabilities_path(@psychologist_profile), local: false, id: 'availability-form', data: { turbo: true } do %>
      <div id="availability-container">
        <% (0..6).each do |day_index| %>
          <div class="day-section" data-day="<%= day_index %>">
            <h2 class="title is-5 has-text-grey-dark mb-4"><%= Date::DAYNAMES[day_index] %></h2>
            <div class="slots">
              <% @availabilities.select { |a| a.day_of_week == day_index }.each_with_index do |availability, slot_index| %>
                <div class="slot" data-id="<%= availability.id %>" 
                     data-start-utc="<%= availability.start_time_of_day&.utc&.iso8601 %>" 
                     data-end-utc="<%= availability.end_time_of_day&.utc&.iso8601 %>">
                  <input type="hidden" name="slots[<%= slot_index %>][day_of_week]" value="<%= day_index %>">
                  <div class="field has-addons">
                    <div class="control">
                      <div class="select is-fullwidth">
                        <select name="slots[<%= slot_index %>][start_time]" class="time-input start-time"></select>
                      </div>
                    </div>
                    <div class="control">
                      <div class="select is-fullwidth">
                        <select name="slots[<%= slot_index %>][end_time]" class="time-input end-time"></select>
                      </div>
                    </div>
                    <div class="control">
                      <button type="button" class="button is-danger is-light delete-slot">Delete</button>
                    </div>
                  </div>
                  <p class="help is-danger" style="display: none;">Both times must be selected and end time must be after start time</p>
                </div>
              <% end %>
            </div>
            <button type="button" class="button is-info is-light add-slot mt-3">Add Slot</button>
          </div>
        <% end %>
      </div>
      <div class="field is-grouped is-grouped-right mt-5">
        <div class="control">
          <button type="submit" class="button is-primary">Save All</button>
        </div>
      </div>
      <input type="hidden" name="browser_timezone" id="browser-timezone-input">
    <% end %>
  </div>
</div>

<style>
  .day-section { margin-bottom: 1.5rem; border: 1px solid #dbdbdb; padding: 1rem; border-radius: 5px; }
  .slot { display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem; background: #f9f9f9; padding: 0.5rem; border-radius: 3px; }
  .slot select, .slot button { padding: 0.25rem; min-width: 120px; font-size: 1rem; }
  .slot .select { width: 100%; }
  .slot .field.has-addons { flex-grow: 1; display: flex; }
  .slot .control { flex-grow: 1; }
  .slot .help.is-danger { display: none; color: red; font-size: 0.8rem; }
  .add-slot { padding: 0.5rem 1rem; }
</style>

<script>
  // Global counter for new slots
  let newSlotIndex = 0;

  // Generate time options (15-minute intervals)
  const TIME_OPTIONS = [];
  for (let h = 0; h < 24; h++) {
    for (let m = 0; m < 60; m += 15) {
      TIME_OPTIONS.push(`${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`);
    }
  }

  // Function to format a UTC ISO string to HH:MM in the browser's local timezone
  function formatUtcToLocalTimeDisplay(utcIsoString) {
    if (!utcIsoString) return '';
    try {
      // Parse the UTC ISO string to get just the hour and minute
      const dbDate = new Date(utcIsoString); // This parses the '2000-01-01T03:00:00.000Z' string as UTC
      const utcHour = dbDate.getUTCHours();
      const utcMinute = dbDate.getUTCMinutes();

      // Create a new Date object for the *current day* in the user's local timezone
      const now = new Date();
      // Set its UTC hours and minutes to match the stored availability time.
      // This forces the Date object to represent the desired UTC time,
      // but when formatted to local time, it will use the *current* date's DST rules.
      now.setUTCHours(utcHour, utcMinute, 0, 0);

      // Now format this 'now' date to the user's local time.
      // toLocaleTimeString will correctly apply the current browser's timezone and DST rules.
      return now.toLocaleTimeString(undefined, {
        hour: '2-digit',
        minute: '2-digit',
        hour12: false,
        timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
      });
    } catch (error) {
      console.error('formatUtcToLocalTimeDisplay error:', error, 'Input:', utcIsoString);
      return '';
    }
  }

  // Function to convert a local time string (HH:MM) to UTC minutes since midnight
  // This is used for client-side validation.
  function toUTCMinutes(timeStr) {
    if (!timeStr) return null;
    try {
      const [hour, minute] = timeStr.split(':').map(Number);
      const date = new Date(); // Use current date for context
      date.setHours(hour, minute, 0, 0); // Set time in browser's local timezone
      const minutes = date.getUTCHours() * 60 + date.getUTCMinutes();
      return minutes;
    } catch (error) {
      console.error('toUTCMinutes error:', error, 'Input:', timeStr);
      return null;
    }
  }

  // Populate select options
  function populateSelect(select, selectedValue) {
    try {
      select.innerHTML = `<option value="">${select.classList.contains('start-time') ? 'Select Start' : 'Select End'}</option>`;
      TIME_OPTIONS.forEach(opt => {
        const option = document.createElement('option');
        option.value = opt;
        option.textContent = opt;
        if (opt === selectedValue) option.selected = true;
        select.appendChild(option);
      });
    } catch (error) {
      console.error('populateSelect error:', error, 'Select:', select.name);
    }
  }

  // Validate slot
  function validateSlot(slot) {
    const startSelect = slot.querySelector('.start-time');
    const endSelect = slot.querySelector('.end-time');
    const error = slot.querySelector('.help.is-danger');
    const startValue = startSelect.value;
    const endValue = endSelect.value;

    if (!startValue || !endValue) {
      error.textContent = 'Both start and end times must be selected';
      error.style.display = 'block';
      return false;
    }

    const startMinutes = toUTCMinutes(startValue);
    const endMinutes = toUTCMinutes(endValue);
    if (endMinutes <= startMinutes) {
      error.textContent = 'End time must be after start time';
      error.style.display = 'block';
      return false;
    }

    error.style.display = 'none';
    return true;
  }

  // Function to initialize and set up event listeners
  function initializeForm() {
    console.log('Initializing form');

    // Set browser timezone display
    const browserTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    const timezoneElement = document.getElementById('browser-timezone');
    if (timezoneElement) {
      timezoneElement.textContent = browserTimezone;
    }

    // Set browser timezone hidden input for backend
    const browserTimezoneInput = document.getElementById('browser-timezone-input');
    if (browserTimezoneInput) {
      browserTimezoneInput.value = browserTimezone;
    }

    document.querySelectorAll('.day-section').forEach(daySection => {
      const slotsContainer = daySection.querySelector('.slots');
      
      // Setup existing slots
      slotsContainer.querySelectorAll('.slot').forEach(slot => {
        const startSelect = slot.querySelector('.start-time');
        const endSelect = slot.querySelector('.end-time');

        // Use data-start-utc and data-end-utc for display conversion
        const startUtc = slot.dataset.startUtc || '';
        const endUtc = slot.dataset.endUtc || '';

        const startTimeDisplay = formatUtcToLocalTimeDisplay(startUtc);
        const endTimeDisplay = formatUtcToLocalTimeDisplay(endUtc);

        populateSelect(startSelect, startTimeDisplay);
        populateSelect(endSelect, endTimeDisplay);

        // Attach event listeners for validation (ensure they are only attached once)
        if (!startSelect.dataset.listenerAttached) {
          startSelect.addEventListener('change', () => validateSlot(slot));
          startSelect.dataset.listenerAttached = 'true';
        }
        if (!endSelect.dataset.listenerAttached) {
          endSelect.addEventListener('change', () => validateSlot(slot));
          endSelect.dataset.listenerAttached = 'true';
        }

        // Attach delete listener (ensure they are only attached once)
        const deleteButton = slot.querySelector('.delete-slot');
        if (deleteButton && !deleteButton.dataset.listenerAttached) {
          deleteButton.addEventListener('click', () => {
            const slotId = slot.dataset.id;
            if (slotId) {
              console.log(`Deleting slot ID: ${slotId}`);
              fetch(`/psychologist_profiles/<%= @psychologist_profile.id %>/psychologist_availabilities/${slotId}`, {
                method: 'DELETE',
                headers: { 
                  'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content,
                  'Content-Type': 'application/json',
                  'Accept': 'text/vnd.turbo-stream.html, text/html'
                }
              }).then(response => {
                console.log(`Delete response: ${response.status}`);
                if (response.ok) {
                  slot.remove();
                  console.log('Slot removed from DOM');
                } else {
                  console.error('Delete failed:', response.status);
                }
              }).catch(err => console.error('Delete error:', err));
            } else {
              console.log('Removing unsaved slot');
              slot.remove();
            }
          });
          deleteButton.dataset.listenerAttached = 'true';
        }
      });

      // Attach Add Slot button listener (ensure it's attached only once)
      const addButton = daySection.querySelector('.add-slot');
      if (addButton && !addButton.dataset.listenerAttached) {
        addButton.addEventListener('click', () => {
          const dayIndex = daySection.dataset.day;
          
          // Create the new slot element
          const newSlot = document.createElement('div');
          newSlot.className = 'slot';
          
          const slotHtml = `
            <input type="hidden" name="slots[new_${newSlotIndex}][day_of_week]" value="${dayIndex}">
            <div class="field has-addons">
              <div class="control">
                <div class="select is-fullwidth">
                  <select name="slots[new_${newSlotIndex}][start_time]" class="time-input start-time"></select>
                </div>
              </div>
              <div class="control">
                <div class="select is-fullwidth">
                  <select name="slots[new_${newSlotIndex}][end_time]" class="time-input end-time"></select>
                </div>
              </div>
              <div class="control">
                <button type="button" class="button is-danger is-light delete-slot">Delete</button>
              </div>
            </div>
            <p class="help is-danger" style="display: none;">Both times must be selected and end time must be after start time</p>
          `;
          newSlot.innerHTML = slotHtml;
          slotsContainer.appendChild(newSlot);

          // Initialize the new slot's dropdowns and listeners
          populateSelect(newSlot.querySelector('.start-time'), '');
          populateSelect(newSlot.querySelector('.end-time'), '');
          
          // Attach listeners for the newly created slot
          newSlot.querySelector('.start-time').addEventListener('change', () => validateSlot(newSlot));
          newSlot.querySelector('.end-time').addEventListener('change', () => validateSlot(newSlot));
          newSlot.querySelector('.delete-slot').addEventListener('click', () => newSlot.remove());
          
          // Increment the global index for the next new slot
          newSlotIndex++;
        });
        addButton.dataset.listenerAttached = 'true'; // Mark as attached
      }
    });

    // Form submission validation
    const form = document.getElementById('availability-form');
    if (form && !form.dataset.listenerAttached) { // Ensure form listener is attached only once
      form.addEventListener('submit', (e) => {
        console.log('Form submission started');
        const slots = document.querySelectorAll('.slot');
        let valid = true;

        slots.forEach(slot => {
          // Only validate if the slot is not empty (i.e., has selected times)
          if (slot.querySelector('.start-time').value || slot.querySelector('.end-time').value) {
            if (!validateSlot(slot)) valid = false;
          }
        });

        if (!valid) {
          console.log('Submission blocked due to validation errors');
          e.preventDefault();
        } else {
          console.log('Form is valid, submitting');
        }
      });
      form.dataset.listenerAttached = 'true'; // Mark form listener as attached
    }
  }

  // Run initialization on Turbo updates
  document.addEventListener('turbo:load', initializeForm);
  // Also run on DOMContentLoaded for initial page load if Turbo doesn't handle it immediately
  document.addEventListener('DOMContentLoaded', initializeForm); 
</script>
